# Simple Bank Back 프로젝트 설계 논의 정리

## 1. 프로젝트 목표

### 핵심 목적
- **메시지 지향 설계** 학습 및 실습
- **TDD** 방법론 적용
- **객체지향 원칙** 체득

### 기능 범위
- 사용자 로그인/로그아웃
- 사용자 정보 조회
- 계좌 조회
- 계좌 이체
- 거래 내역(자금 흐름) 조회

### 기술 스택
- Java 17
- Spring Boot 3.x
- Gradle
- JUnit 5
- H2 Database

---

## 2. 아키텍처 논의 과정

### 고려했던 구조들

#### 1) 전통적 레이어드 구조
```
controller / service / repository / domain
```
- 문제: 도메인별 응집도가 떨어짐

#### 2) 기능별 구조
```
user / account / transaction
```
- 장점: 도메인별 응집도 높음
- 문제: 내부 구조 정의 필요

#### 3) 인터페이스/구현체 분리 구조
```
domain/
├── interface/
│   ├── controller/
│   ├── service/
│   └── repository/
└── implements/
    ├── controller/
    ├── service/
    └── repository/
```
- 문제: 깊은 폴더 구조, 파일 찾기 어려움

#### 4) 헥사고날 아키텍처 (최종 선택)
```
user/
├── domain/              # 핵심 비즈니스 로직
├── application/         # UseCase 구현
├── port/
│   ├── in/             # 들어오는 메시지 (인터페이스)
│   └── out/            # 나가는 메시지 (인터페이스)
└── adapter/
    ├── in/
    │   └── web/        # Controller
    └── out/
        └── persistence/ # Repository
```

### 헥사고날을 선택한 이유
- **메시지 = 포트(Port)**: 외부와의 계약/인터페이스
- **메시지 처리 = 어댑터(Adapter)**: 실제 구현
- **도메인**: 순수한 비즈니스 로직
- 인터페이스(외부 계약)와 구현체의 명확한 분리

---

## 3. 핵심 개념 정리

### 메시지와 객체지향

**"객체지향의 사실과 오해" 핵심 원칙:**
- 객체가 먼저가 아니라 **메시지가 먼저**
- 메시지를 받는 대상(수신자)을 인터페이스로 추상화
- 송신자는 구체적 구현을 모르고, 추상화된 수신자에게 메시지 전송

```
클라이언트 → [인터페이스] ← 구현체
         (의존)        (구현)
```

### TDD와 객체지향의 관계

**언뜻 충돌처럼 보이는 이유:**
- 객체지향 전통 가르침: 인터페이스 먼저 설계 → 구현
- TDD: 테스트 먼저 → 구현 → (필요시) 인터페이스 추출

**실제로는 충돌이 아닌 시간축의 차이:**
- TDD는 "좋은 객체지향 설계로 가는 과정"
- 인터페이스를 미리 만들지 말고, **필요가 드러날 때** 추출
- "설계는 발현되는 것(Emergent Design)" - Kent Beck

### Outside-In TDD 방식
```
1. 가장 바깥쪽(사용자 시나리오)부터 테스트 작성
2. 테스트 작성 중 "이 객체가 저 객체에게 뭘 요청해야 하네?" → 메시지 발견
3. 필요한 협력자를 Mock으로 만들면서 인터페이스 발견
4. 구현 완료 후 필요시 인터페이스 추출
```

---

## 4. 개발 프로세스

### 전체 흐름

```
1. 메시지 정의 (시나리오 기반)
   ↓
2. TDD로 테스트 작성 (메시지 구체화)
   ↓
3. 구현하면서 협력자 발견
   ↓
4. 협력자를 인터페이스로 추상화
   ↓
5. 의존성 방향 정리 (DIP 적용)
```

### 구체적 단계

#### Step 1: 메시지 목록 작성
- 사용자 시나리오 기반
- "무엇을 해야 하는가" 중심

#### Step 2: 각 메시지별 인터페이스 설계
- Port (in/out) 정의
- 메시지 계약 명확화

#### Step 3: TDD로 구현
- 테스트 작성 (Red)
- 구현 (Green)
- 리팩토링 및 인터페이스 추출 (Refactor)

#### Step 4: 협력 구조 검증
- 객체 간 메시지 흐름 확인
- 의존성 방향 검증

---

## 5. 디렉토리 구조 vs 개발 순서

### 디렉토리 구조 (목표 아키텍처)
```
simple-bank-back/
├── src/main/java/com/simplebank/
│   ├── user/
│   │   ├── domain/
│   │   ├── application/
│   │   ├── port/
│   │   │   ├── in/
│   │   │   └── out/
│   │   └── adapter/
│   │       ├── in/web/
│   │       └── out/persistence/
│   ├── account/
│   └── transaction/
└── src/test/java/
```

### 실제 구현 순서
1. `domain/` - 도메인 모델 (Entity)
2. `application/` - UseCase 구현체 (TDD)
3. `adapter/` - Controller, Repository 구현체
4. `port/` - 필요시 인터페이스 추출

**폴더 구조는 완성형을 미리 만들되, 구현은 TDD로 점진적으로!**

---

## 6. 다음 단계

1. ✅ 프로젝트 기본 설정 완료
2. ✅ 아키텍처 결정 (헥사고날)
3. 📝 메시지 목록 작성 (다음 작업)
4. 각 메시지별 TDD 구현
5. 협력 구조 검증 및 리팩토링

---

## 7. 핵심 인사이트

### Kent Beck & Martin Fowler의 원칙
- **Kent Beck**: "객체에게 무엇을 하라고 말하지 말고, 무엇이 필요한지 물어봐라"
- **Martin Fowler**: "인터페이스는 클라이언트의 필요에 의해 발견되어야 한다"
- **공통점**: 의존성 역전 원칙 (DIP) - 구체적인 것에서 추상적인 것으로

### 메시지 중심 설계의 본질
- 메시지 ≠ 인터페이스
- 메시지를 **받는 대상**을 인터페이스로 추상화
- 송신자는 구현을 모르고 추상화된 수신자에게 메시지 전송

### TDD와 객체지향의 조화
- TDD는 객체지향과 충돌하지 않음
- **목표(아키텍처)와 과정(TDD)의 차이**
- TDD를 통해 자연스럽게 좋은 객체지향 설계로 수렴